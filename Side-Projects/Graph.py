## ATTENTION !!!
## NOTE: Most parts of this project were generated by AI and then reviewed and adapted by me. I do not claim full authorship of the code, and it should not be interpreted as entirely my own work.
# =========================
# BACKEND (Windows safe)
# =========================
import matplotlib
matplotlib.use("TkAgg")

import matplotlib.pyplot as plt
from matplotlib.ticker import MultipleLocator
import csv
import numpy as np

# =========================
# LOAD CSV DATA
# =========================
days = []
prod_scores = []
social_scores = []
notes_social = []
notes_productivity = []

with open("progress_preview_full.csv", newline="", encoding="utf-8") as f:
    reader = csv.DictReader(f)
    for row in reader:
        days.append(int(row["day"]))
        prod_scores.append(int(row["productivity"]))
        social_scores.append(int(row["social"]))
        notes_social.append(row.get("notesocial", ""))
        notes_productivity.append(row.get("productivitynote", ""))

days = np.array(days)
prod_scores = np.array(prod_scores)
social_scores = np.array(social_scores)

# =========================
# CONSTANTS
# =========================
X_MIN, X_MAX = 0, 365
PROD_MIN, PROD_MAX = 0, 100
SOCIAL_MIN, SOCIAL_MAX = 0, 100

# =========================
# FIGURE & AXES
# =========================
fig, ax = plt.subplots(figsize=(10, 6))
ax2 = ax.twinx()

fig.subplots_adjust(left=0.04, right=0.96, bottom=0.06, top=0.98)

ax.set_xlim(X_MIN, X_MAX)
ax.set_ylim(PROD_MIN, PROD_MAX)
ax2.set_ylim(SOCIAL_MIN, SOCIAL_MAX)

ax.set_xlabel("Days")
ax.set_ylabel("Productivity Score")
ax2.set_ylabel("Social Score")

ax.yaxis.set_major_locator(MultipleLocator(5))
ax2.yaxis.set_major_locator(MultipleLocator(10))

ax.grid(True, which="major", linestyle="--", alpha=0.4)

# =========================
# PLOT DATA
# =========================
ax.plot(days, prod_scores, linewidth=1, zorder=2)
prod_points = ax.scatter(days, prod_scores, zorder=3)

ax2.plot(days, social_scores, color="orange", linewidth=1.5, zorder=1)
social_points = ax2.scatter(days, social_scores, color="orange", s=40, zorder=2)

# =========================
# ANNOTATIONS
# =========================
annot_prod = ax.annotate(
    "",
    xy=(0, 0),
    xytext=(10, 10),
    textcoords="offset points",
    bbox=dict(boxstyle="round", fc="white", alpha=0.9),
    arrowprops=dict(arrowstyle="->")
)
annot_prod.set_visible(False)

annot_social = ax2.annotate(
    "",
    xy=(0, 0),
    xytext=(10, 10),
    textcoords="offset points",
    bbox=dict(boxstyle="round", fc="white", alpha=0.9),
    arrowprops=dict(arrowstyle="->")
)
annot_social.set_visible(False)

# =========================
# HOVER HANDLER
# =========================
def on_move(event):
    annot_prod.set_visible(False)
    annot_social.set_visible(False)

    contains_prod, ind_prod = prod_points.contains(event)
    if contains_prod:
        i = ind_prod["ind"][0]
        annot_prod.xy = (days[i], prod_scores[i])
        annot_prod.set_text(
            f"Day: {days[i]}\n"
            f"Productivity: {prod_scores[i]}\n\n"
            f"Productivity Note:\n"
            f"{notes_productivity[i].replace('\\n', '\n')}"
        )
        annot_prod.set_visible(True)
        fig.canvas.draw_idle()
        return

    contains_social, ind_social = social_points.contains(event)
    if contains_social:
        i = ind_social["ind"][0]
        annot_social.xy = (days[i], social_scores[i])
        annot_social.set_text(
            f"Day: {days[i]}\n"
            f"Social: {social_scores[i]}\n\n"
            f"Social Note:\n"
            f"{notes_social[i].replace('\\n', '\n')}"
        )
        annot_social.set_visible(True)
        fig.canvas.draw_idle()

# =========================
# X TICK MANAGEMENT
# =========================
def update_ticks():
    x_min, x_max = ax.get_xlim()
    visible_days = x_max - x_min

    if visible_days > 200:
        step = 50
    elif visible_days > 100:
        step = 20
    elif visible_days > 50:
        step = 10
    elif visible_days > 20:
        step = 5
    else:
        step = 1

    ax.xaxis.set_major_locator(MultipleLocator(step))

# =========================
# ZOOM (SCROLL)
# =========================
def on_scroll(event):
    if event.inaxes not in (ax, ax2) or event.xdata is None:
        return

    scale = 0.9 if event.button == "up" else 1.1
    x_min, x_max = ax.get_xlim()

    width = min((x_max - x_min) * scale, X_MAX - X_MIN)
    center = event.xdata

    left = max(X_MIN, center - width / 2)
    right = min(X_MAX, left + width)

    ax.set_xlim(left, right)
    update_ticks()
    fig.canvas.draw_idle()

# =========================
# PAN (CLICK + DRAG)
# =========================
is_panning = False
pan_start_x = None
pan_start_xlim = None

def on_press(event):
    global is_panning, pan_start_x, pan_start_xlim
    if event.inaxes not in (ax, ax2) or event.button != 1:
        return
    is_panning = True
    pan_start_x = event.xdata
    pan_start_xlim = ax.get_xlim()

def on_release(event):
    global is_panning
    is_panning = False

def on_motion(event):
    if not is_panning or event.inaxes not in (ax, ax2) or event.xdata is None:
        return

    dx = pan_start_x - event.xdata
    left, right = pan_start_xlim
    width = right - left

    left = max(X_MIN, min(left + dx, X_MAX - width))
    ax.set_xlim(left, left + width)

    update_ticks()
    fig.canvas.draw_idle()

# =========================
# INIT
# =========================
update_ticks()

fig.canvas.mpl_connect("motion_notify_event", on_move)
fig.canvas.mpl_connect("scroll_event", on_scroll)
fig.canvas.mpl_connect("button_press_event", on_press)
fig.canvas.mpl_connect("button_release_event", on_release)
fig.canvas.mpl_connect("motion_notify_event", on_motion)

plt.show()
